ეს პროგრამა ქმნის შემთხვევით გენერირებულ ლაბირინთს, სადაც მინიმუმ ერთი გზა არსებობს სტარტიდან ფინიშამდე. 
ლაბირინთის ამოხსნა ხდება BFS ალგორითმით, რომელიც მინიმალურ გზას პოულობს და ამ გზას 'O' სიმბოლოებით აღნიშნავს.
DFS გამოიყენება ლაბირინთის გენერირებისთვის. BFS გამოიყენება ამოხსნისთვის.
ეს ალგორითმი იძლევა ლაბირინთების გენერირების, ვიზუალიზაციის და ამოხსნის მარტივ და ეფექტურ გზას.

1. ფუნქცია: create_empty_maze(n)
    ეს ფუნქცია ქმნის საწყის, ცარიელ ლაბირინთს, სადაც ყველა უჯრა შევსებულია სიმბოლოთი '#' (დაბლოკილი უჯრა). 
    გარე საზღვრები ავტომატურად ივსება დაბლოკილი უჯრებით, რათა ლაბირინთს ჰქონდეს ჩარჩო.

2. ფუნქცია: generate_maze_with_path(n)
    ეს ფუნქცია იყენებს DFS (სიღრმეში ძიების) ალგორითმს, რათა ლაბირინთში შექმნას გზა, რომელიც მიგიყვანს სტარტის (S) წერტილიდან ფინიშის (F) წერტილამდე.

    ლაბირინთის შემადგენლობა:
        იწყება ლაბირინთის გენერირებით (create_empty_maze). ლაბირინთში დგინდება სტარტი (S) და ფინიში (F).

    DFS ალგორითმი:
        იწყება (1, 1) პოზიციიდან და შემთხვევით არჩევს მიმართულებებს, რათა ლაბირინთში გახსნას გზა.
        DFS ალგორითმის მექანიზმი:
            directions: მიმართულებები (მარჯვნივ, ქვემოთ, მარცხნივ, ზემოთ).
            random.shuffle(): შემთხვევითია მიმართულებების არჩევა, რათა ყოველ ჯერზე განსხვავებული ლაბირინთი შეიქმნას.

        გადაადგილება 2 უჯრის დაშორებით:
            nx, ny = x + dx * 2, y + dy * 2
            ეს უზრუნველყოფს, რომ ყოველი ნაბიჯი გამოიწვევს მინიმუმ 1 დაბლოკილი უჯრის მოხსნას.

    ფინიშთან მისასვლელი გზის უზრუნველყოფა:
        if maze[n - 2][n - 3] == '#' and maze[n - 3][n - 2] == '#':
            if random.choice([True, False]):
                maze[n - 2][n - 3] = ' '
            else:
                maze[n - 3][n - 2] = ' '
        ეს ლოგიკა ამოწმებს, რომ ფინიშთან მისასვლელად მინიმუმ ერთი გზა იყოს გახსნილი.

3. ფუნქცია: print_maze(maze)
    ეს ფუნქცია ლაბირინთს გამოსახავს ტერმინალზე, ყოველი რიგი გამოყოფილია "".join(row)-ის საშუალებით.

4. ფუნქცია: bfs(maze, start, end)
    ეს არის BFS (სიგანის ძიების) ალგორითმი, რომელიც მოიძიებს მინიმალურ გზას სტარტის (S) წერტილიდან ფინიშის (F) წერტილამდე.

BFS-ის ძირითადი ლოგიკა:
    რიგი (queue) გამოიყენება მეზობელი უჯრების გასავლელად:

    queue = [start]
    visited = set([start])
    მშობელი რუკის (parent_map) გამოყენებით აღდგება გზა.

    თუ რიგში არსებული წერტილი ფინიშს ემთხვევა:

    if (x, y) == end:
        while (x, y) != start:
            maze[x][y] = 'O'  # გზის აღნიშვნა
            x, y = parent_map[(x, y)]
        return True
    ეს ციკლი ხსნის გზას, სადაც 'O' აღნიშნავს გავლილ მარშრუტს.

    თუ ვერ იპოვა გზა, აბრუნებს False.

5. ფუნქცია: solve_maze(maze)
    ეს ფუნქცია ცდილობს ლაბირინთში გზის პოვნას და გამოიძახებს BFS-ს. თუ გზა მოიძებნა, ტერმინალზე გამოიტანს მარშრუტს.